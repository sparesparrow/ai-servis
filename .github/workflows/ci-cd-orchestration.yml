name: ðŸš€ AI-SERVIS Universal CI/CD Orchestration

on:
  push:
    branches: [ main, develop, feature/* ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main, develop ]
  schedule:
    - cron: '0 6 * * 1'  # Weekly security scan on Mondays

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '18'
  CONAN_VERSION: '2.0'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ================================
  # SECURITY & COMPLIANCE SCANNING
  # ================================
  security-scan:
    name: ðŸ”’ Security & Compliance
    runs-on: ubuntu-latest
    permissions:
      security-events: write
      contents: read
      actions: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH,MEDIUM'

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

      - name: CodeQL Analysis
        uses: github/codeql-action/init@v3
        with:
          languages: python, cpp, javascript
          config-file: ./.github/codeql/codeql-config.yml

      - name: Autobuild
        uses: github/codeql-action/autobuild@v3

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3
        with:
          category: "/language:${{matrix.language}}"

      - name: OWASP Dependency Check
        uses: dependency-check/Dependency-Check_Action@main
        with:
          project: 'ai-servis-universal'
          path: '.'
          format: 'SARIF'
          args: >
            --enableRetired
            --enableExperimental
            --nvdApiKey ${{ secrets.NVD_API_KEY }}

      - name: Upload OWASP results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: reports/dependency-check-report.sarif

      - name: Snyk Security Scan
        uses: snyk/actions/python@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --sarif-file-output=snyk.sarif --severity-threshold=medium

      - name: Upload Snyk results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: snyk.sarif

  # ================================
  # CODE QUALITY & LINTING
  # ================================
  code-quality:
    name: ðŸ“Š Code Quality & Linting
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          pip install --upgrade pip
          pip install -r requirements-dev.txt
          pip install pre-commit black isort flake8 mypy bandit safety

      - name: Cache pre-commit
        uses: actions/cache@v3
        with:
          path: ~/.cache/pre-commit
          key: pre-commit-${{ runner.os }}-${{ hashFiles('.pre-commit-config.yaml') }}

      - name: Run pre-commit hooks
        run: pre-commit run --all-files --show-diff-on-failure

      - name: Python security check with Bandit
        run: bandit -r . -f json -o bandit-report.json || true

      - name: Python safety check
        run: safety check --json --output safety-report.json || true

      - name: Upload quality reports
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: code-quality-reports
          path: |
            bandit-report.json
            safety-report.json

  # ================================
  # MULTI-PLATFORM C++ BUILDS
  # ================================
  cpp-builds:
    name: ðŸ”§ C++ Multi-Platform Build
    needs: [security-scan, code-quality]
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            arch: x86_64
            profile: linux-release
            conan_arch: x86_64
            target: linux-amd64
          - os: ubuntu-latest
            arch: arm64
            profile: linux-arm64
            conan_arch: armv8
            target: linux-arm64
          - os: macos-latest
            arch: x86_64
            profile: macos-release
            conan_arch: x86_64
            target: darwin-amd64
          - os: windows-latest
            arch: x86_64
            profile: windows-release
            conan_arch: x86_64
            target: windows-amd64

    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install Conan
        run: |
          pip install conan==${{ env.CONAN_VERSION }}
          conan profile detect --force

      - name: Cache Conan packages
        uses: actions/cache@v3
        with:
          path: ~/.conan2
          key: conan-${{ runner.os }}-${{ matrix.arch }}-${{ hashFiles('conanfile.py', 'profiles/${{ matrix.profile }}') }}
          restore-keys: |
            conan-${{ runner.os }}-${{ matrix.arch }}-

      - name: Configure cross-compilation (ARM64)
        if: matrix.arch == 'arm64' && matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc-aarch64-linux-gnu g++-aarch64-linux-gnu

      - name: Build with orchestrator
        run: |
          python build_orchestrator.py orchestrator-config.yaml --parallel

      - name: Run unit tests
        if: matrix.os != 'windows-latest'
        run: |
          cd platforms/cpp/build
          ctest --output-on-failure --parallel $(nproc)

      - name: Package artifacts
        run: |
          mkdir -p artifacts/${{ matrix.target }}
          find platforms/cpp/build -name "*.so" -o -name "*.dll" -o -name "*.dylib" -o -name "hardware-server*" -o -name "mcp-server*" | \
            xargs -I {} cp {} artifacts/${{ matrix.target }}/

      - name: Upload build artifacts
        uses: actions/upload-artifact@v3
        with:
          name: cpp-${{ matrix.target }}-binaries
          path: artifacts/${{ matrix.target }}/
          retention-days: 30

  # ================================
  # ANDROID BUILD & DEPLOYMENT
  # ================================
  android-build:
    name: ðŸ“± Android Build & Deploy
    needs: [security-scan, code-quality]
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Cache Gradle packages
        uses: actions/cache@v3
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
            android/.gradle
          key: gradle-${{ runner.os }}-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            gradle-${{ runner.os }}-

      - name: Set up Android SDK
        uses: android-actions/setup-android@v3

      - name: Grant execute permission for gradlew
        run: chmod +x android/gradlew

      - name: Build debug APK
        run: |
          cd android
          ./gradlew assembleDebug --stacktrace --scan

      - name: Run unit tests
        run: |
          cd android
          ./gradlew testDebugUnitTest --continue

      - name: Run instrumented tests
        uses: reactivecircus/android-emulator-runner@v2
        with:
          api-level: 29
          script: cd android && ./gradlew connectedAndroidTest

      - name: Build release artifacts
        if: github.ref == 'refs/heads/main'
        env:
          KEYSTORE_BASE64: ${{ secrets.ANDROID_KEYSTORE_BASE64 }}
          KEY_ALIAS: ${{ secrets.ANDROID_KEY_ALIAS }}
          KEY_PASSWORD: ${{ secrets.ANDROID_KEY_PASSWORD }}
          STORE_PASSWORD: ${{ secrets.ANDROID_KEYSTORE_PASSWORD }}
        run: |
          echo "$KEYSTORE_BASE64" | base64 -d > android/keystore/release.keystore
          cd android
          ./gradlew bundleRelease assembleRelease --stacktrace

      - name: Upload APK artifacts
        uses: actions/upload-artifact@v3
        with:
          name: android-apk
          path: |
            android/app/build/outputs/apk/debug/app-debug.apk
            android/app/build/outputs/apk/release/app-release.apk
            android/app/build/outputs/bundle/release/app-release.aab

      - name: Deploy to Play Console
        if: github.ref == 'refs/heads/main'
        uses: r0adkll/upload-google-play@v1
        with:
          serviceAccountJsonPlainText: ${{ secrets.PLAY_STORE_CONFIG_JSON }}
          packageName: cz.aiservis.app
          releaseFiles: android/app/build/outputs/bundle/release/app-release.aab
          track: internal
          status: completed

  # ================================
  # ESP32 FIRMWARE BUILDS
  # ================================
  esp32-firmware:
    name: ðŸ”Œ ESP32 Firmware Build
    needs: [security-scan, code-quality]
    strategy:
      matrix:
        target: [esp32, esp32s3]
        variant: [obd, io, cam]
    
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup ESP-IDF
        uses: espressif/esp-idf-ci-action@v1
        with:
          esp-idf-version: v5.1
          target: ${{ matrix.target }}

      - name: Cache ESP-IDF
        uses: actions/cache@v3
        with:
          path: |
            ~/.espressif
            esp32/firmware-${{ matrix.variant }}/build
          key: esp-idf-${{ matrix.target }}-${{ matrix.variant }}-${{ hashFiles('esp32/firmware-${{ matrix.variant }}/**') }}

      - name: Build firmware
        run: |
          cd esp32/firmware-${{ matrix.variant }}
          idf.py set-target ${{ matrix.target }}
          idf.py build

      - name: Create firmware package
        run: |
          cd esp32/firmware-${{ matrix.variant }}
          mkdir -p dist
          cp build/*.bin dist/
          cp build/partition_table/*.bin dist/ 2>/dev/null || true
          
          # Generate manifest with checksums
          python3 -c "
          import json
          import hashlib
          import os
          
          def get_checksum(file_path):
              with open(file_path, 'rb') as f:
                  return hashlib.sha256(f.read()).hexdigest()
          
          files = [f for f in os.listdir('dist') if f.endswith('.bin')]
          checksums = {f: get_checksum(f'dist/{f}') for f in files}
          
          manifest = {
              'version': '1.0.0',
              'target': '${{ matrix.target }}',
              'variant': '${{ matrix.variant }}',
              'build_number': '${{ github.run_number }}',
              'commit': '${{ github.sha }}',
              'files': files,
              'checksums': checksums
          }
          
          with open('dist/manifest.json', 'w') as f:
              json.dump(manifest, f, indent=2)
          "

      - name: Sign firmware (Release)
        if: github.ref == 'refs/heads/main'
        env:
          ESP32_PRIVATE_KEY: ${{ secrets.ESP32_PRIVATE_KEY }}
        run: |
          cd esp32/firmware-${{ matrix.variant }}/dist
          echo "$ESP32_PRIVATE_KEY" | base64 -d > private.key
          for bin_file in *.bin; do
            openssl dgst -sha256 -sign private.key -out "${bin_file}.sig" "$bin_file"
          done
          rm private.key

      - name: Upload firmware artifacts
        uses: actions/upload-artifact@v3
        with:
          name: esp32-${{ matrix.target }}-${{ matrix.variant }}
          path: esp32/firmware-${{ matrix.variant }}/dist/

  # ================================
  # DOCKER MULTI-PLATFORM BUILDS
  # ================================
  docker-builds:
    name: ðŸ³ Multi-Platform Docker Images
    needs: [cpp-builds, code-quality]
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        component:
          - core-orchestrator
          - ai-audio-assistant
          - hardware-bridge
          - ai-security

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Download C++ artifacts
        uses: actions/download-artifact@v3
        with:
          pattern: cpp-*-binaries
          path: artifacts/

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${{ matrix.component }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: modules/${{ matrix.component }}/Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1
            VERSION=${{ github.ref_name }}
            COMMIT=${{ github.sha }}
            BUILD_DATE=${{ steps.meta.outputs.created }}

  # ================================
  # SYSTEM INTEGRATION TESTS
  # ================================
  integration-tests:
    name: ðŸ§ª System Integration Tests
    needs: [docker-builds]
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: test
          POSTGRES_DB: ai_servis_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          pip install --upgrade pip
          pip install -r requirements.txt
          pip install -r requirements-dev.txt
          pip install pytest pytest-cov pytest-xdist pytest-mock

      - name: Start test environment
        run: |
          docker-compose -f docker-compose.dev.yml up -d --wait
          sleep 30  # Allow services to fully start

      - name: Run integration tests
        env:
          POSTGRES_URL: postgresql://postgres:test@localhost:5432/ai_servis_test
          REDIS_URL: redis://localhost:6379
          MQTT_BROKER: localhost:1883
        run: |
          pytest tests/integration/ \
            --cov=modules \
            --cov-report=xml \
            --cov-report=html \
            --junit-xml=junit.xml \
            -v --tb=short

      - name: Run system tests
        run: |
          python test_orchestrator.py
          python test_orchestrator_simple.py

      - name: Upload test results
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: test-results
          path: |
            htmlcov/
            junit.xml
            coverage.xml

      - name: Publish test results
        uses: EnricoMi/publish-unit-test-result-action@v2
        if: always()
        with:
          files: junit.xml

  # ================================
  # PERFORMANCE & LOAD TESTING
  # ================================
  performance-tests:
    name: âš¡ Performance & Load Testing
    needs: [integration-tests]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.event_name == 'schedule'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install performance testing tools
        run: |
          pip install locust pytest-benchmark memory-profiler
          npm install -g artillery

      - name: Start performance test environment
        run: |
          docker-compose -f docker-compose.yml up -d --wait
          sleep 60

      - name: Run API performance tests
        run: |
          artillery run tests/performance/api-load-test.yml

      - name: Run voice processing benchmarks
        run: |
          python -m pytest tests/performance/voice_benchmark.py \
            --benchmark-only \
            --benchmark-json=benchmark-results.json

      - name: Run memory profiling
        run: |
          mprof run python modules/core-orchestrator/main.py --test-mode
          mprof plot -o memory-profile.png

      - name: Upload performance results
        uses: actions/upload-artifact@v3
        with:
          name: performance-results
          path: |
            benchmark-results.json
            memory-profile.png
            artillery-report.json

  # ================================
  # DEPLOYMENT
  # ================================
  deploy:
    name: ðŸš€ Deploy to Environments
    needs: [integration-tests, performance-tests]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
    
    strategy:
      matrix:
        environment: 
          - ${{ github.ref == 'refs/heads/main' && 'production' || 'staging' }}

    environment:
      name: ${{ matrix.environment }}
      url: ${{ steps.deploy.outputs.url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Deploy to EKS
        id: deploy
        run: |
          aws eks update-kubeconfig --region ${{ vars.AWS_REGION }} --name ${{ vars.EKS_CLUSTER_NAME }}
          
          # Apply Kubernetes manifests
          kubectl apply -f deploy/kubernetes/${{ matrix.environment }}/
          
          # Wait for deployment
          kubectl rollout status deployment/core-orchestrator -n ai-servis-${{ matrix.environment }}
          
          # Get service URL
          SERVICE_URL=$(kubectl get service core-orchestrator-lb -n ai-servis-${{ matrix.environment }} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          echo "url=https://$SERVICE_URL" >> $GITHUB_OUTPUT

      - name: Run smoke tests
        run: |
          python tests/smoke/smoke_tests.py --url ${{ steps.deploy.outputs.url }}

      - name: Notify deployment
        uses: 8398a7/action-slack@v3
        if: always()
        with:
          status: ${{ job.status }}
          channel: '#deployments'
          webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}
          fields: repo,message,commit,author,action,eventName,ref,workflow

  # ================================
  # RELEASE MANAGEMENT
  # ================================
  release:
    name: ðŸ“¦ Create Release
    needs: [deploy]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v3
        with:
          path: release-artifacts/

      - name: Generate release notes
        id: release_notes
        run: |
          python scripts/generate_release_notes.py \
            --version ${{ github.ref_name }} \
            --output release-notes.md

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          body_path: release-notes.md
          files: |
            release-artifacts/**/*
          draft: false
          prerelease: ${{ contains(github.ref, 'alpha') || contains(github.ref, 'beta') || contains(github.ref, 'rc') }}

      - name: Update documentation
        run: |
          python scripts/update_docs_version.py --version ${{ github.ref_name }}
          
      - name: Deploy documentation
        run: |
          mkdocs gh-deploy --force

  # ================================
  # CLEANUP & MAINTENANCE
  # ================================
  cleanup:
    name: ðŸ§¹ Cleanup & Maintenance
    runs-on: ubuntu-latest
    if: always()
    needs: [security-scan, code-quality, cpp-builds, android-build, esp32-firmware, docker-builds, integration-tests, performance-tests, deploy, release]
    
    steps:
      - name: Cleanup old artifacts
        uses: actions/github-script@v7
        with:
          script: |
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId,
            });
            
            // Keep artifacts for 30 days, clean up older ones
            const thirtyDaysAgo = new Date();
            thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
            
            for (const artifact of artifacts.data.artifacts) {
              const createdAt = new Date(artifact.created_at);
              if (createdAt < thirtyDaysAgo) {
                await github.rest.actions.deleteArtifact({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  artifact_id: artifact.id,
                });
              }
            }

      - name: Update workflow status
        if: always()
        run: |
          echo "Workflow completed with status: ${{ job.status }}"
          echo "Build number: ${{ github.run_number }}"
          echo "Commit SHA: ${{ github.sha }}"