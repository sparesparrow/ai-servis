# Code Style Guidelines for Downloader Project

## Overview
This document outlines the coding standards and conventions for the WebGrab downloader project. These guidelines are designed to improve code quality, maintainability, and consistency by adopting best practices from enterprise C++ development (inspired by the OMS project patterns).

## File Structure and Organization

### Directory Layout
- `src/` - Core library source files
- `src/Utils/` - Utility classes and helpers
- `src/Examples/` - Example usage code
- `src/MCPIntegration/` - MCP protocol integration
- `src/TinyMCP/` - MCP protocol implementation
- `src/.cursor/rules/` - Development rules and guidelines

### File Naming
- **Headers**: `.h` extension, PascalCase (e.g., `DownloadJob.h`)
- **Sources**: `.cpp` extension, matching header name
- **Templates**: `.hpp` extension for template-heavy files
- **Test files**: `*_test.cpp` or `*_tests.cpp`

## Include Management

### Fundamental Principles
- **Minimal includes**: Only include what you need
- **Forward declarations**: Use instead of includes when possible
- **Include what you use**: Don't rely on transitive includes
- **Consistent ordering**: Follow the same pattern in all files

### Include Order and Grouping
Always order includes in this exact sequence:

1. **Matching header** (for .cpp files only)
2. **Local project headers** (quotes, alphabetical within groups)
3. **Standard library headers** (angle brackets, alphabetical)
4. **Third-party headers** (angle brackets, alphabetical)

```cpp
// 1. Matching header (only in .cpp files)
#include "DownloadJob.h"

// 2. Local project headers (alphabetically)
// Interfaces and base classes
#include "IJob.h"
#include "IResponseWriter.h"

// Implementation classes
#include "CurlClientWrapper.h"
#include "MessageQueueProcessor.h"

// 3. Standard library headers (alphabetically)
#include <filesystem>
#include <memory>
#include <string>
#include <utility>

// 4. Third-party headers (alphabetically)
#include <curl/curl.h>
#include <flatbuffers/flatbuffers.h>
```

### Include Guards
Use `#pragma once` exclusively:

```cpp
#pragma once  // Always use this, never traditional guards
```

### Forward Declarations
Use forward declarations to reduce compilation dependencies:

```cpp
#pragma once

// Forward declarations instead of includes
class IResponseWriter;
class TcpSocket;
struct DownloadRequest;

// Include only what's needed for class definition
#include "IJob.h"

class DownloadJob : public IJob {
private:
    std::shared_ptr<IResponseWriter> responseWriter;
    std::unique_ptr<TcpSocket> socket;
    // ...
};
```

### Include in Implementation Files
```cpp
// DownloadJob.cpp
#include "DownloadJob.h"           // Matching header first
#include "CurlClientWrapper.h"     // Local includes
#include "IResponseWriter.h"
#include <filesystem>              // Standard library
#include <iostream>
#include <utility>
#include <curl/curl.h>             // Third-party
```

### Include Best Practices

#### DO: Use forward declarations for types used only as pointers/references
```cpp
// In header - forward declare
class TcpSocket;
class IResponseWriter;

// In implementation - include
#include "TcpSocket.h"
#include "IResponseWriter.h"
```

#### DON'T: Include headers unnecessarily
```cpp
// Bad - includes header just for a typedef
#include "ComplexType.h"  // Only used for typedef ComplexType::Handle

// Good - forward declare and include only in .cpp
class ComplexType;  // Forward declaration in .h
#include "ComplexType.h"  // Include in .cpp
```

#### DO: Group related includes logically
```cpp
// Interfaces group
#include "IJob.h"
#include "IResponseWriter.h"
#include "IRequestReader.h"

// Implementation classes group
#include "DownloadJob.h"
#include "WebGrabClient.h"
#include "MessageQueueProcessor.h"
```

#### DON'T: Mix different types of includes
```cpp
// Bad - mixed ordering
#include <string>
#include "IJob.h"
#include <memory>
#include "DownloadJob.h"

// Good - grouped by type
#include "IJob.h"
#include "DownloadJob.h"
#include <memory>
#include <string>
```

#### DO: Use full paths for clarity
```cpp
// Preferred - explicit paths
#include "Utils/ThreadSafeQueue.hpp"
#include "MCPIntegration/MCPClient.h"

// Avoid - relative paths that assume directory structure
#include "../Utils/ThreadSafeQueue.hpp"
```

### Common Include Patterns

#### Interface Headers
```cpp
#pragma once

// Minimal includes - only what's needed for declarations
#include <cstdint>
#include <string>

class IJob {
public:
    virtual ~IJob() = default;
    virtual void execute() = 0;
    virtual uint32_t getId() const = 0;
};
```

#### Implementation Headers
```cpp
#pragma once

// Forward declarations for dependencies
class IResponseWriter;
class CurlClient;

// Include base classes and templates
#include "IJob.h"
#include <memory>
#include <string>

class DownloadJob : public IJob {
public:
    DownloadJob(std::shared_ptr<IResponseWriter> writer,
                std::string url,
                uint32_t sessionId);

    void execute() override;
    uint32_t getId() const override;

private:
    std::shared_ptr<IResponseWriter> responseWriter;
    std::string url;
    uint32_t sessionId;
    std::unique_ptr<CurlClient> curlClient;
};
```

#### Template Headers (.hpp)
```cpp
#pragma once

#include <memory>
#include <mutex>
#include <queue>
#include <condition_variable>

// All template dependencies must be included
template<typename T>
class ThreadSafeQueue {
    // Template implementation...
};
```

## Header Files (.h)

### Structure Template
```cpp
#pragma once

// Local includes (alphabetically)
// Interfaces and base classes first
#include "IInterface.h"
#include "IBaseClass.h"

// Implementation classes
#include "HelperClass.h"

// Standard library includes (alphabetically)
#include <memory>
#include <string>
#include <vector>

// Third-party includes (alphabetically)
#include <curl/curl.h>

namespace WebGrab {

// Forward declarations
class SomeClass;

/**
 * @brief Brief description of the class purpose
 *
 * Detailed description if needed, explaining the class responsibility
 * and any important design decisions.
 */
class DownloadJob : public IJob {
public:
    // Public methods first
    explicit DownloadJob(std::shared_ptr<IResponseWriter> writer,
                        std::string url,
                        uint32_t sessionId,
                        std::string outputPath);
    ~DownloadJob() override = default;

    void execute() override;
    [[nodiscard]] uint32_t getSessionId() const;
    [[nodiscard]] const std::string& getUrl() const;

private:
    // Private methods
    void initializeCurlClient();
    bool validateInputs() const;

    // Member variables (camelCase, no trailing underscore)
    std::shared_ptr<IResponseWriter> responseWriter;
    std::string url;
    uint32_t sessionId{0};
    std::string outputPath;
    std::unique_ptr<CurlClient> curlClient;
};

} // namespace WebGrab
```

### Key Requirements
- **Include guards**: Use `#pragma once`
- **Include ordering**: Strict alphabetical grouping by type
- **Forward declarations**: Use when possible to reduce dependencies
- **Minimal includes**: Only include what you directly use
- **Documentation**: Doxygen-style comments for classes and public methods

## Source Files (.cpp)

### Structure Template
```cpp
#include "DownloadJob.h"
#include "CurlClientWrapper.h"
#include "IResponseWriter.h"

// Standard library includes
#include <filesystem>
#include <iostream>
#include <utility>

namespace WebGrab {

DownloadJob::DownloadJob(std::shared_ptr<IResponseWriter> writer,
                        std::string url,
                        uint32_t sessionId,
                        std::string outputPath)
    : responseWriter(std::move(writer))
    , url(std::move(url))
    , sessionId(sessionId)
    , outputPath(std::move(outputPath))
    , curlClient(std::make_unique<CurlClient>())
{
    initializeCurlClient();
    if (!validateInputs()) {
        throw std::invalid_argument("Invalid download job parameters");
    }
}

void DownloadJob::execute() {
    try {
        std::vector<std::string> headers;
        const CURLcode result = curlClient->getFile(url.c_str(),
                                                   outputPath.c_str(),
                                                   headers,
                                                   true);

        if (result == CURLE_OK) {
            responseWriter->writeStatusResponse(sessionId, "Completed");
        } else {
            responseWriter->writeStatusResponse(sessionId, "Failed");
        }
    } catch (const std::exception& e) {
        responseWriter->writeStatusResponse(sessionId, "Error");
        // Log error appropriately
    }
}

[[nodiscard]] uint32_t DownloadJob::getSessionId() const {
    return sessionId;
}

[[nodiscard]] const std::string& DownloadJob::getUrl() const {
    return url;
}

void DownloadJob::initializeCurlClient() {
    curlClient->init(nullptr, nullptr, false);
}

bool DownloadJob::validateInputs() const {
    return !url.empty() && !outputPath.empty() && sessionId > 0;
}

} // namespace WebGrab
```

### Key Requirements
- **Include order**: Header file first, then other local headers, then standard library
- **Namespace usage**: Always wrap implementations in namespace blocks
- **Exception safety**: Use RAII and smart pointers
- **Error handling**: Prefer exceptions for constructor failures, error codes for runtime issues

## Naming Conventions

### Classes and Types
- **Class names**: PascalCase (`DownloadJob`, `MessageQueueProcessor`)
- **Interface names**: PascalCase with 'I' prefix (`IJob`, `IResponseWriter`)
- **Struct names**: PascalCase (`JobInfo`, `DownloadRequest`)
- **Enum names**: PascalCase (`JobStatus`, `RequestType`)
- **Enum values**: PascalCase (`JobStatus::Downloading`)

### Variables and Members
- **Local variables**: camelCase (`responseWriter`, `sessionId`)
- **Member variables**: camelCase (no prefix/suffix) (`responseWriter`, `url`)
- **Function parameters**: camelCase (`writer`, `sessionId`)
- **Constants**: SCREAMING_SNAKE_CASE (`MAX_RETRIES`, `DEFAULT_TIMEOUT`)

### Functions and Methods
- **Function names**: camelCase (`execute()`, `getSessionId()`)
- **Getter methods**: `getPropertyName()` with `[[nodiscard]]`
- **Setter methods**: `setPropertyName(value)`
- **Boolean methods**: `isProperty()`, `hasProperty()`, `canAction()`
- **Factory methods**: `createInstance()`, `makeObject()`

## Code Quality Standards

### Const Correctness
```cpp
// Good
[[nodiscard]] const std::string& getUrl() const;
void processData(const DataBuffer& buffer);
void setUrl(std::string newUrl);

// Avoid
std::string& getUrl();  // Missing const and nodiscard
void processData(DataBuffer buffer);  // Unnecessary copy
```

### Smart Pointer Usage
```cpp
// Prefer these
std::unique_ptr<CurlClient> client = std::make_unique<CurlClient>();
std::shared_ptr<IResponseWriter> writer = std::make_shared<ResponseWriter>();

// Avoid these
CurlClient* client = new CurlClient();  // Manual memory management
auto client = std::unique_ptr<CurlClient>(new CurlClient());  // Don't use new
```

### Error Handling
```cpp
// Prefer exceptions for construction/initialization
class DownloadJob {
public:
    DownloadJob(/* params */) {
        if (!validateInputs()) {
            throw std::invalid_argument("Invalid parameters");
        }
    }
};

// Use error codes/optional for runtime operations
std::optional<DownloadResult> performDownload() {
    if (/* error condition */) {
        return std::nullopt;
    }
    return DownloadResult{/* success data */};
}
```

### Modern C++ Features

#### Auto and Type Deduction
```cpp
// Good uses of auto
auto result = functionReturningComplexType();
auto& reference = getReference();
const auto iterator = container.find(key);

// Avoid when clarity suffers
auto x = 42;  // What type is this?
```

#### Range-based Loops
```cpp
// Preferred
for (const auto& job : jobs) {
    job->execute();
}

// Avoid traditional loops when possible
for (size_t i = 0; i < jobs.size(); ++i) {
    jobs[i]->execute();
}
```

#### Lambda Expressions
```cpp
// Good for small, local operations
auto completedJobs = std::count_if(jobs.begin(), jobs.end(),
    [](const auto& job) { return job->isCompleted(); });

// Avoid complex lambdas - use named functions
```

### Threading and Concurrency
```cpp
class ThreadSafeQueue {
private:
    mutable std::mutex mutex_;
    std::queue<T> queue_;
    std::condition_variable condition_;

public:
    void push(T item) {
        std::lock_guard<std::mutex> lock(mutex_);
        queue_.push(std::move(item));
        condition_.notify_one();
    }

    bool pop(T& item) {
        std::unique_lock<std::mutex> lock(mutex_);
        condition_.wait(lock, [this] { return !queue_.empty() || shutdown_; });

        if (queue_.empty()) return false;

        item = std::move(queue_.front());
        queue_.pop();
        return true;
    }
};
```

## Documentation Standards

### Doxygen Comments
```cpp
/**
 * @brief Downloads a file from the specified URL
 *
 * This method performs an HTTP GET request to download the file
 * and saves it to the specified output path.
 *
 * @param url The URL to download from
 * @param outputPath The local path to save the file
 * @return true if download succeeded, false otherwise
 *
 * @throws NetworkException if network error occurs
 * @throws FileException if file cannot be written
 */
bool downloadFile(const std::string& url, const std::string& outputPath);
```

### Code Comments
```cpp
// Use for complex logic explanation
// DON'T use for obvious code

// Good: Explains why, not what
for (const auto& job : activeJobs) {
    // Cancel jobs that have exceeded timeout to prevent resource leaks
    if (job->getElapsedTime() > timeout) {
        job->cancel();
    }
}
```

## Testing Guidelines

### Unit Test Structure
```cpp
#include <gtest/gtest.h>
#include "DownloadJob.h"

class DownloadJobTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Setup test fixtures
    }

    void TearDown() override {
        // Cleanup
    }

    // Test fixtures
    std::shared_ptr<MockResponseWriter> mockWriter;
    std::unique_ptr<DownloadJob> downloadJob;
};

TEST_F(DownloadJobTest, ExecuteSuccess) {
    // Arrange
    EXPECT_CALL(*mockWriter, writeStatusResponse(_, "Completed"));

    // Act
    downloadJob->execute();

    // Assert
    // Assertions are handled by mocks
}
```

### Test File Naming
- `DownloadJobTest.cpp` or `DownloadJob_tests.cpp`
- Place in `tests/` directory mirroring source structure

## Build and Configuration

### CMake Standards
```cmake
# Preferred structure
cmake_minimum_required(VERSION 3.16)
project(WebGrab VERSION 1.0.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

# Options
option(WEBGRAB_BUILD_TESTS "Build unit tests" ON)
option(WEBGRAB_BUILD_EXAMPLES "Build example applications" ON)

# Dependencies
find_package(CURL REQUIRED)
find_package(Threads REQUIRED)

# Library target
add_library(webgrab_lib)
target_sources(webgrab_lib
    PRIVATE
        DownloadJob.cpp
        WebGrabClient.cpp
    PUBLIC
        FILE_SET HEADERS
        FILES
            DownloadJob.h
            WebGrabClient.h
)

target_link_libraries(webgrab_lib
    PUBLIC
        CURL::libcurl
        Threads::Threads
)

# Applications
add_executable(webgrab-client main_client.cpp)
target_link_libraries(webgrab-client PRIVATE webgrab_lib)
```

## Code Review Checklist

### Include Management
- [ ] `#pragma once` used instead of traditional include guards
- [ ] Includes ordered by type: matching header → local → standard → third-party
- [ ] Local includes use quotes, external includes use angle brackets
- [ ] Includes alphabetized within each group
- [ ] Forward declarations used instead of includes when possible
- [ ] No unnecessary includes (include what you use, not what you transitively get)
- [ ] No circular dependencies introduced

### Code Quality
- [ ] Namespace usage consistent (`WebGrab` or `TinyMCP::Utils`)
- [ ] Naming conventions followed (PascalCase classes, camelCase variables/methods)
- [ ] Const correctness applied (`[[nodiscard]]` on getters, const methods)
- [ ] Smart pointers used appropriately (`std::unique_ptr`, `std::shared_ptr`)
- [ ] Error handling appropriate for context (exceptions for construction, optionals for runtime)
- [ ] Documentation present for public APIs (Doxygen style)
- [ ] Unit tests written and passing
- [ ] No compiler warnings
- [ ] Code builds on all target platforms

## Migration Guide

### From Current to Recommended Style

1. **Member Variables**: Change `variable_name_` to `variableName`
2. **Getter Methods**: Add `[[nodiscard]]` and `const`
3. **Error Handling**: Replace basic error handling with proper exceptions/optionals
4. **Documentation**: Add Doxygen comments to public interfaces
5. **Includes**: Reorder and minimize includes
6. **Namespaces**: Ensure consistent namespace usage

### Gradual Migration
- Start with new files following the new style
- Migrate existing files during refactoring
- Use clang-format or similar tools for automated formatting
- Update code reviews to enforce new standards

## Tooling

### Recommended Tools
- **Compiler**: GCC 11+ or Clang 14+ with C++20 support
- **Build System**: CMake 3.16+
- **Testing**: Google Test
- **Code Coverage**: gcov/lcov
- **Static Analysis**: clang-tidy, cppcheck
- **Formatting**: clang-format with project style

### Clang-Format Configuration
```yaml
Language: Cpp
BasedOnStyle: Google
ColumnLimit: 100
IndentWidth: 4
TabWidth: 4
UseTab: Never
AccessModifierOffset: -4
AlignAfterOpenBracket: Align
AllowShortFunctionsOnASingleLine: false
```
